import dynamic from "next/dynamic";
import Head from "next/head";
import Link from "next/link";
import { useCallback, useRef, useState, useEffect } from "react";
import "@tensorflow/tfjs";
import * as handPoseDetection from "@tensorflow-models/hand-pose-detection";
import Webcam from "react-webcam";
import { PixelInput } from "@tensorflow-models/hand-pose-detection/dist/shared/calculators/interfaces/common_interfaces";
import { CaptureController } from "../components/captureController";
import { MutableRefObject } from "react";
import { updatePoses } from "../lib/updatePoses";

const Capture = () => {
  const Sketch = dynamic<{
    handsRef: MutableRefObject<handPoseDetection.Keypoint[][]>;
  }>(() => import(`../components/capturePreviewFingers`), {
    ssr: false, // <- ここで ssr を無効にするオプションを渡す
  });
  const webcamRef = useRef<null | Webcam>(null);
  const modelRef = useRef<null | handPoseDetection.HandDetector>(null);
  const requestRef = useRef<null | number>(null);
  const predictionsRef = useRef<null | handPoseDetection.Hand[]>(null);
  const [ready, setReady] = useState(false);
  const lostCountRef = useRef(0);
  const timer = 120000;
  const keyflames = useRef<
    [handPoseDetection.Keypoint[][], handPoseDetection.Keypoint[][]]
  >([[], []]);
  const handsRef = useRef<handPoseDetection.Keypoint[][]>([]);

  const capture = useCallback(async () => {
    if (webcamRef.current && modelRef.current) {
      //webcamとmodelのインスタンスが生成されていたら
      const predictions = await modelRef.current.estimateHands(
        webcamRef.current?.getCanvas() as PixelInput
      ); //webcamの現時点でのフレームを取得し、ポーズ推定の結果をpredictionsに非同期で格納

      if (predictions) {
        //predictionsが存在していたら
        if (predictions.length > 0) {
          predictionsRef.current = predictions;
          [keyflames.current, handsRef.current] = updatePoses({
            predictionsRef: predictionsRef as MutableRefObject<
              handPoseDetection.Hand[]
            >,
            poses: keyflames.current,
          });
          lostCountRef.current = 0;
        } else {
          lostCountRef.current++;
        }

        if (lostCountRef.current > 10) {
          predictionsRef.current = [];
        }
      }
    }

    // need to fix: ready stateが更新されてもなお同じreadyの値がよばれ続けてしまう
    if (ready) {
      requestRef.current = requestAnimationFrame(capture); //captureを実施
    } else {
      //not working
      requestRef.current = null;
    }
  }, [ready]);

  useEffect(() => {
    const load = async () => {
      const model = handPoseDetection.SupportedModels.MediaPipeHands;
      const detectorConfig = {
        runtime: "tfjs",
        modelType: "full",
      } as handPoseDetection.MediaPipeHandsTfjsModelConfig;
      modelRef.current = await handPoseDetection.createDetector(
        model,
        detectorConfig
      );
    };

    load();

    setReady(true);
    setInterval("location.reload()", timer);
  }, []);

  useEffect(() => {
    if (ready) {
      requestRef.current = requestAnimationFrame(capture);
    } else {
      if (requestRef.current) {
        console.log("cancel");
        cancelAnimationFrame(requestRef.current); //not working
      }
    }
  }, [capture, ready]);
  return (
    <>
      <Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main>
        <CaptureController handsRef={handsRef} />
        <ul style={{ position: "absolute" }}>
          <li>
            <Link href="/">Top</Link>
          </li>
        </ul>
        <div>
          {/* //optional sketch */}
          {ready && <Sketch handsRef={handsRef} />}
        </div>
        <div
          style={{
            position: "absolute",
            right: -190,
            top: -10,
          }}
        >
          <Webcam
            width="200"
            height="113"
            mirrored
            id="webcam"
            audio={false}
            ref={webcamRef}
            screenshotFormat="image/jpeg"
          />
        </div>
        <div
          style={{
            backgroundColor: "rgba(23,32,23,0.3)",
            position: "absolute",
            color: "white",
            display: "flex",
            cursor: "pointer",
            top: 10,
            left: 10,
          }}
        ></div>
      </main>
    </>
  );
};

export default Capture;
